// Generated by CoffeeScript 1.8.0
(function() {
  var DOWN, KEYCODES, KeyboardController, LEFT, Level, RIGHT, Snake, UP, init, xy,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  xy = function(x, y) {
    return {
      x: x,
      y: y,
      is: function(point) {
        return this.x === point.x && this.y === point.y;
      }
    };
  };

  UP = xy(0, -1);

  DOWN = xy(0, 1);

  LEFT = xy(-1, 0);

  RIGHT = xy(1, 0);

  KEYCODES = {
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    A: 65,
    D: 68,
    S: 83,
    W: 87
  };

  KeyboardController = (function() {
    function KeyboardController() {
      this.keyState = __bind(this.keyState, this);
      this.keyEvent = __bind(this.keyEvent, this);
    }

    KeyboardController.prototype._watched_keys = {};

    KeyboardController.prototype._keys_down = [];

    KeyboardController.prototype.addCombo = function(snake, keys) {
      var key, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        _results.push(this._watched_keys[key] = snake);
      }
      return _results;
    };

    KeyboardController.prototype.keyEvent = function(e, pressed) {
      var key, key_idx, snake;
      key = e.which;
      key_idx = this._keys_down.indexOf(key);
      if (key_idx !== -1 && pressed === true) {
        return;
      }
      snake = this._watched_keys[key];
      if (snake != null) {
        snake.handleKey(key, pressed);
      }
      if (pressed === true) {
        return this._keys_down.push(key);
      } else {
        return this._keys_down.splice(key_idx, 1);
      }
    };

    KeyboardController.prototype.keyState = function(key) {
      return _keys_down.indexOf(key !== -1);
    };

    return KeyboardController;

  })();

  Level = (function() {
    function Level(canvas, cell, primary, secondary) {
      if (canvas == null) {
        canvas = document.querySelector('canvas');
      }
      this.cell = cell != null ? cell : 10;
      this.primary = primary != null ? primary : '#525252';
      this.secondary = secondary != null ? secondary : '#f2d435';
      this.scoreMap = __bind(this.scoreMap, this);
      this.createFood = __bind(this.createFood, this);
      this.paint = __bind(this.paint, this);
      this.paintCell = __bind(this.paintCell, this);
      this.getTime = __bind(this.getTime, this);
      this.ctx = canvas.getContext('2d');
      this.px_width = canvas.width;
      this.px_height = canvas.height;
      this.width = this.px_width / this.cell;
      this.height = this.px_height / this.cell;
      this.createFood();
      this.clock = 0;
    }

    Level.prototype.getTime = function() {
      return this.clock;
    };

    Level.prototype.paintCell = function(x, y) {
      this.ctx.fillStyle = this.primary;
      return this.ctx.fillRect(x * this.cell, y * this.cell, this.cell, this.cell);
    };

    Level.prototype.paint = function() {
      var node, score_pair, snake, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.ctx.fillStyle = this.secondary;
      this.ctx.fillRect(0, 0, this.px_width, this.px_height);
      _ref = Snake.getPlayers();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snake = _ref[_i];
        snake.step();
        _ref1 = snake.nodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          node = _ref1[_j];
          this.paintCell(node.x, node.y);
        }
      }
      this.paintCell(this.food.x, this.food.y);
      _ref2 = this.score_pairs;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        score_pair = _ref2[_k];
        score_pair[0].innerHTML = score_pair[1].getScore();
      }
      return this.clock++;
    };

    Level.prototype.createFood = function() {
      return this.food = xy(Math.round(Math.random() * (this.width - 1)), Math.round(Math.random() * (this.height - 1)));
    };

    Level.prototype.scoreMap = function() {
      var i, snake, _i, _len, _ref, _results;
      this.score_pairs = [];
      _ref = Snake.getPlayers();
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        snake = _ref[i];
        _results.push(this.score_pairs.push([document.getElementById("score" + (i + 1)), snake]));
      }
      return _results;
    };

    return Level;

  })();

  Snake = (function() {
    Snake._players = [];

    Snake.getPlayer = function(num) {
      return this._players[num - 1];
    };

    Snake.getPlayers = function() {
      return this._players;
    };

    Snake.prototype._direction = {};

    Snake.prototype._load_direction = {};

    function Snake(direction, load, up, down, left, right) {
      this.load = load;
      this.step = __bind(this.step, this);
      this.checkCollisionPoint = __bind(this.checkCollisionPoint, this);
      this.checkCollision = __bind(this.checkCollision, this);
      this.reset = __bind(this.reset, this);
      this.handleKey = __bind(this.handleKey, this);
      this.getHead = __bind(this.getHead, this);
      this.setScore = __bind(this.setScore, this);
      this.getScore = __bind(this.getScore, this);
      this.setSpeed = __bind(this.setSpeed, this);
      this.getSpeed = __bind(this.getSpeed, this);
      this.setDirection = __bind(this.setDirection, this);
      this.getDirection = __bind(this.getDirection, this);
      Snake._players.push(this);

      /*
      -- TODO --
      This is totally redundant with the first few
      lines of reset()
       */
      this._direction = this._load_direction = direction;
      this._score = 0;
      this._speed = 2;

      /*
      -- TODO --
      Make the directions in a loop.
       */
      this.keys = {};
      this.keys[up] = {
        direction: UP
      };
      this.keys[down] = {
        direction: DOWN
      };
      this.keys[left] = {
        direction: LEFT
      };
      this.keys[right] = {
        direction: RIGHT
      };
      key_controller.addCombo(this, [up, down, left, right]);
      this.reset();
    }

    Snake.prototype.getDirection = function() {
      return this._direction;
    };

    Snake.prototype.setDirection = function(dir, reset) {
      if (reset == null) {
        reset = false;
      }
      if (reset === true || (dir.x * this.getDirection().x + dir.y * this.getDirection().y) !== -1) {
        this._direction = dir;
        return this.setSpeed(1);
      }
    };

    Snake.prototype.getSpeed = function() {
      return this._speed;
    };

    Snake.prototype.setSpeed = function(speed) {
      return this._speed = speed;
    };

    Snake.prototype.getScore = function() {
      return this._score;
    };

    Snake.prototype.setScore = function(score) {
      return this._score = score;
    };

    Snake.prototype.getHead = function() {
      return xy(this.nodes[0].x + this.getDirection().x, this.nodes[0].y + this.getDirection().y);
    };

    Snake.prototype.handleKey = function(key, pressed) {
      var dir;
      dir = this.keys[key].direction;
      if (pressed === true) {
        return this.setDirection(dir);
      } else if (dir.is(this.getDirection())) {
        return this.setSpeed(2);
      }
    };

    Snake.prototype.reset = function() {
      var i, _i, _ref, _results;
      this.setDirection(this._load_direction, true);
      this.setScore(Math.max(this.getScore() - 2, 0));
      this.setSpeed(2);
      this.nodes = [];
      _results = [];
      for (i = _i = _ref = this.getScore() + 4; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        _results.push(this.nodes.unshift(xy(this.load.x - i * this._load_direction.x, this.load.y - i * this._load_direction.y)));
      }
      return _results;
    };

    Snake.prototype.checkCollision = function(head) {
      var snake, _i, _len, _ref, _ref1, _ref2;
      if ((0 <= (_ref = head.x) && _ref < level.width) && (0 <= (_ref1 = head.y) && _ref1 < level.height)) {
        _ref2 = Snake.getPlayers();
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          snake = _ref2[_i];
          if (snake.checkCollisionPoint(head)) {
            if (this.checkCollisionPoint(snake.getHead())) {
              snake.reset();
            }
            return true;
          }
        }
        return false;
      } else {
        return true;
      }
    };

    Snake.prototype.checkCollisionPoint = function(point) {
      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (point.is(node)) {
          return true;
        }
      }
      return false;
    };

    Snake.prototype.step = function() {
      var head;
      if (level.getTime() % (Math.pow(2, this.getSpeed())) === 0) {
        head = this.getHead();
        if (this.checkCollision(head) === true) {
          return this.reset();
        } else {
          if (head.is(level.food)) {
            this.setScore(this.getScore() + 1);
            level.createFood();
          } else {
            this.nodes.pop();
          }
          return this.nodes.unshift(head);
        }
      }
    };

    return Snake;

  })();

  (init = function() {

    /*
    TODO
    deal with window.yuck
     */
    var game_loop, p1, p2;
    window.key_controller = new KeyboardController;
    window.level = new Level();
    p1 = new Snake(xy(1, 0), xy(0, 0), KEYCODES.W, KEYCODES.S, KEYCODES.A, KEYCODES.D);
    p2 = new Snake(xy(-1, 0), xy(level.width - 1, level.height - 1), KEYCODES.UP, KEYCODES.DOWN, KEYCODES.LEFT, KEYCODES.RIGHT);
    level.scoreMap();
    document.addEventListener('keydown', function(e) {
      return key_controller.keyEvent(e, true);
    });
    document.addEventListener('keyup', function(e) {
      return key_controller.keyEvent(e, false);
    });
    return game_loop = setInterval(level.paint, 16.667);
  })();

}).call(this);

//# sourceMappingURL=snake.js.map
