// Generated by CoffeeScript 1.6.3
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

$(function() {
  var DOWN, LEFT, Level, PRIMARY, RIGHT, SECONDARY, Snake, UP, init, level, xy;
  UP = LEFT = -1;
  DOWN = RIGHT = 1;
  PRIMARY = '#f40';
  SECONDARY = '#333';
  level = [];
  xy = function(x, y) {
    return {
      x: x,
      y: y,
      is: function(point) {
        return this.x === point.x && this.y === point.y;
      }
    };
  };
  Level = (function() {
    function Level(canvas, cell) {
      if (canvas == null) {
        canvas = $('canvas');
      }
      this.cell = cell != null ? cell : 10;
      this.createFood = __bind(this.createFood, this);
      this.paint = __bind(this.paint, this);
      this.paintCell = __bind(this.paintCell, this);
      this.ctx = canvas[0].getContext('2d');
      this.px_width = canvas.width();
      this.px_height = canvas.height();
      this.width = this.px_width / this.cell;
      this.height = this.px_height / this.cell;
      this.createFood();
    }

    Level.prototype.paintCell = function(x, y) {
      this.ctx.fillStyle = PRIMARY;
      return this.ctx.fillRect(x * this.cell, y * this.cell, this.cell, this.cell);
    };

    Level.prototype.paint = function() {
      var node, score_text, snake, _i, _j, _len, _len1, _ref, _ref1;
      this.ctx.fillStyle = SECONDARY;
      this.ctx.fillRect(0, 0, this.px_width, this.px_height);
      _ref = Snake.getPlayers();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snake = _ref[_i];
        snake.step();
        _ref1 = snake.nodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          node = _ref1[_j];
          this.paintCell(node.x, node.y);
        }
      }
      this.paintCell(this.food.x, this.food.y);
      score_text = "Score 1: " + (Snake.getPlayer(1).score) + "     Score 2: " + (Snake.getPlayer(2).score);
      return this.ctx.fillText(score_text, 5, this.px_height - 5);
    };

    Level.prototype.createFood = function() {
      return this.food = xy(Math.round(Math.random() * (this.width - 1)), Math.round(Math.random() * (this.height - 1)));
    };

    return Level;

  })();
  Snake = (function() {
    /*
    
    @direction [x, y]
      Direction of motion.
      [1, 0]:  Left
      [-1, 0]: Right
      [0, 1]:  Down
      [0, -1]: Up
    
    @load [x, y]
      Starting position of the tail node.
      [0, 0] represents the level's top left corner.
    */

    Snake._players = [];

    Snake.getPlayer = function(num) {
      return this._players[num - 1];
    };

    Snake.getPlayers = function() {
      return this._players;
    };

    Snake.prototype._buffer_direction = {};

    Snake.prototype._direction = {};

    Snake.prototype._load_direction = {};

    Snake.prototype.getDirection = function() {
      return this._direction;
    };

    Snake.prototype.setX = function(x) {
      return this._buffer_direction = xy(x, 0);
    };

    Snake.prototype.setY = function(y) {
      return this._buffer_direction = xy(0, y);
    };

    Snake.prototype.resetSnakePosition = function() {
      var i, _i, _results;
      this._buffer_direction = this._direction = this._load_direction;
      this.nodes = [];
      _results = [];
      for (i = _i = 4; _i >= 0; i = --_i) {
        _results.push(this.nodes.push(xy(this.load.x + i * this._load_direction.x, this.load.y + i * this._load_direction.y)));
      }
      return _results;
    };

    Snake.prototype.checkCollision = function(point) {
      var node, _i, _len, _ref, _ref1, _ref2;
      if ((0 <= (_ref = point.x) && _ref < level.width) && (0 <= (_ref1 = point.y) && _ref1 < level.height)) {
        _ref2 = this.nodes;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          node = _ref2[_i];
          if (point.is(node)) {
            return true;
          }
        }
        return false;
      } else {
        return true;
      }
    };

    Snake.prototype.step = function() {
      var head;
      this._direction = this._buffer_direction;
      head = xy(this.nodes[0].x + this.getDirection().x, this.nodes[0].y + this.getDirection().y);
      if (this.checkCollision(head) === true) {
        this.resetSnakePosition();
        this.score = 0;
      } else {
        if (head.is(level.food)) {
          this.score++;
          level.createFood();
        } else {
          this.nodes.pop();
        }
        return this.nodes.unshift(head);
      }
    };

    function Snake(direction, load) {
      this.load = load;
      this.step = __bind(this.step, this);
      this.checkCollision = __bind(this.checkCollision, this);
      this.resetSnakePosition = __bind(this.resetSnakePosition, this);
      this.setY = __bind(this.setY, this);
      this.setX = __bind(this.setX, this);
      this.getDirection = __bind(this.getDirection, this);
      Snake._players.push(this);
      this._buffer_direction = this._direction = this._load_direction = direction;
      this.score = 0;
      this.speed = 5;
      this.resetSnakePosition();
    }

    return Snake;

  })();
  $(document).keydown(function(e) {
    switch (e.which) {
      case 65:
        if (Snake.getPlayer(1).getDirection().x !== RIGHT) {
          return Snake.getPlayer(1).setX(LEFT);
        }
        break;
      case 87:
        if (Snake.getPlayer(1).getDirection().y !== DOWN) {
          return Snake.getPlayer(1).setY(UP);
        }
        break;
      case 68:
        if (Snake.getPlayer(1).getDirection().x !== LEFT) {
          return Snake.getPlayer(1).setX(RIGHT);
        }
        break;
      case 83:
        if (Snake.getPlayer(1).getDirection().y !== UP) {
          return Snake.getPlayer(1).setY(DOWN);
        }
        break;
      case 37:
        if (Snake.getPlayer(2).getDirection().x !== RIGHT) {
          return Snake.getPlayer(2).setX(LEFT);
        }
        break;
      case 38:
        if (Snake.getPlayer(2).getDirection().y !== DOWN) {
          return Snake.getPlayer(2).setY(UP);
        }
        break;
      case 39:
        if (Snake.getPlayer(2).getDirection().x !== LEFT) {
          return Snake.getPlayer(2).setX(RIGHT);
        }
        break;
      case 40:
        if (Snake.getPlayer(2).getDirection().y !== UP) {
          return Snake.getPlayer(2).setY(DOWN);
        }
    }
  });
  return (init = function() {
    var game_loop, p1, p2;
    level = new Level();
    p1 = new Snake(xy(1, 0), xy(0, 0));
    p2 = new Snake(xy(-1, 0), xy(level.width - 1, level.height - 1));
    return game_loop = setInterval(level.paint, 60);
  })();
});

/*
//@ sourceMappingURL=snake.map
*/
